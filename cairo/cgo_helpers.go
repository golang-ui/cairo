// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sat, 06 Jan 2018 18:31:25 EST.
// By https://git.io/c-for-go. DO NOT EDIT.

package cairo

/*
#cgo pkg-config: cairo
#include "cairo.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *Cairo) Ref() *C.cairo_t {
	if x == nil {
		return nil
	}
	return (*C.cairo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Cairo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCairoRef converts the C object reference into a raw struct reference without wrapping.
func NewCairoRef(ref unsafe.Pointer) *Cairo {
	return (*Cairo)(ref)
}

// NewCairo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCairo() *Cairo {
	return (*Cairo)(allocCairoMemory(1))
}

// allocCairoMemory allocates memory for type C.cairo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCairoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCairoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCairoValue = unsafe.Sizeof([1]C.cairo_t{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Cairo) PassRef() *C.cairo_t {
	if x == nil {
		x = (*Cairo)(allocCairoMemory(1))
	}
	return (*C.cairo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Surface) Ref() *C.cairo_surface_t {
	if x == nil {
		return nil
	}
	return (*C.cairo_surface_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Surface) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSurfaceRef converts the C object reference into a raw struct reference without wrapping.
func NewSurfaceRef(ref unsafe.Pointer) *Surface {
	return (*Surface)(ref)
}

// NewSurface allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSurface() *Surface {
	return (*Surface)(allocSurfaceMemory(1))
}

// allocSurfaceMemory allocates memory for type C.cairo_surface_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceValue = unsafe.Sizeof([1]C.cairo_surface_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Surface) PassRef() *C.cairo_surface_t {
	if x == nil {
		x = (*Surface)(allocSurfaceMemory(1))
	}
	return (*C.cairo_surface_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Device) Ref() *C.cairo_device_t {
	if x == nil {
		return nil
	}
	return (*C.cairo_device_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Device) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceRef(ref unsafe.Pointer) *Device {
	return (*Device)(ref)
}

// NewDevice allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDevice() *Device {
	return (*Device)(allocDeviceMemory(1))
}

// allocDeviceMemory allocates memory for type C.cairo_device_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceValue = unsafe.Sizeof([1]C.cairo_device_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Device) PassRef() *C.cairo_device_t {
	if x == nil {
		x = (*Device)(allocDeviceMemory(1))
	}
	return (*C.cairo_device_t)(unsafe.Pointer(x))
}

// allocMatrixMemory allocates memory for type C.cairo_matrix_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrixValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrixValue = unsafe.Sizeof([1]C.cairo_matrix_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Matrix) Ref() *C.cairo_matrix_t {
	if x == nil {
		return nil
	}
	return x.ref6fd9c783
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Matrix) Free() {
	if x != nil && x.allocs6fd9c783 != nil {
		x.allocs6fd9c783.(*cgoAllocMap).Free()
		x.ref6fd9c783 = nil
	}
}

// NewMatrixRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMatrixRef(ref unsafe.Pointer) *Matrix {
	if ref == nil {
		return nil
	}
	obj := new(Matrix)
	obj.ref6fd9c783 = (*C.cairo_matrix_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Matrix) PassRef() (*C.cairo_matrix_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6fd9c783 != nil {
		return x.ref6fd9c783, nil
	}
	mem6fd9c783 := allocMatrixMemory(1)
	ref6fd9c783 := (*C.cairo_matrix_t)(mem6fd9c783)
	allocs6fd9c783 := new(cgoAllocMap)
	allocs6fd9c783.Add(mem6fd9c783)

	var cxx_allocs *cgoAllocMap
	ref6fd9c783.xx, cxx_allocs = (C.double)(x.Xx), cgoAllocsUnknown
	allocs6fd9c783.Borrow(cxx_allocs)

	var cyx_allocs *cgoAllocMap
	ref6fd9c783.yx, cyx_allocs = (C.double)(x.Yx), cgoAllocsUnknown
	allocs6fd9c783.Borrow(cyx_allocs)

	var cxy_allocs *cgoAllocMap
	ref6fd9c783.xy, cxy_allocs = (C.double)(x.Xy), cgoAllocsUnknown
	allocs6fd9c783.Borrow(cxy_allocs)

	var cyy_allocs *cgoAllocMap
	ref6fd9c783.yy, cyy_allocs = (C.double)(x.Yy), cgoAllocsUnknown
	allocs6fd9c783.Borrow(cyy_allocs)

	var cx0_allocs *cgoAllocMap
	ref6fd9c783.x0, cx0_allocs = (C.double)(x.X0), cgoAllocsUnknown
	allocs6fd9c783.Borrow(cx0_allocs)

	var cy0_allocs *cgoAllocMap
	ref6fd9c783.y0, cy0_allocs = (C.double)(x.Y0), cgoAllocsUnknown
	allocs6fd9c783.Borrow(cy0_allocs)

	x.ref6fd9c783 = ref6fd9c783
	x.allocs6fd9c783 = allocs6fd9c783
	return ref6fd9c783, allocs6fd9c783

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Matrix) PassValue() (C.cairo_matrix_t, *cgoAllocMap) {
	if x.ref6fd9c783 != nil {
		return *x.ref6fd9c783, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Matrix) Deref() {
	if x.ref6fd9c783 == nil {
		return
	}
	x.Xx = (float64)(x.ref6fd9c783.xx)
	x.Yx = (float64)(x.ref6fd9c783.yx)
	x.Xy = (float64)(x.ref6fd9c783.xy)
	x.Yy = (float64)(x.ref6fd9c783.yy)
	x.X0 = (float64)(x.ref6fd9c783.x0)
	x.Y0 = (float64)(x.ref6fd9c783.y0)
}

// Ref returns a reference to C object as it is.
func (x *Pattern) Ref() *C.cairo_pattern_t {
	if x == nil {
		return nil
	}
	return (*C.cairo_pattern_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Pattern) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPatternRef converts the C object reference into a raw struct reference without wrapping.
func NewPatternRef(ref unsafe.Pointer) *Pattern {
	return (*Pattern)(ref)
}

// NewPattern allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPattern() *Pattern {
	return (*Pattern)(allocPatternMemory(1))
}

// allocPatternMemory allocates memory for type C.cairo_pattern_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPatternMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPatternValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPatternValue = unsafe.Sizeof([1]C.cairo_pattern_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Pattern) PassRef() *C.cairo_pattern_t {
	if x == nil {
		x = (*Pattern)(allocPatternMemory(1))
	}
	return (*C.cairo_pattern_t)(unsafe.Pointer(x))
}

func (x DestroyFunc) PassRef() (ref *C.cairo_destroy_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if destroyFunc6936EE15Func == nil {
		destroyFunc6936EE15Func = x
	}
	return (*C.cairo_destroy_func_t)(C.cairo_destroy_func_t_6936ee15), nil
}

func (x DestroyFunc) PassValue() (ref C.cairo_destroy_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if destroyFunc6936EE15Func == nil {
		destroyFunc6936EE15Func = x
	}
	return (C.cairo_destroy_func_t)(C.cairo_destroy_func_t_6936ee15), nil
}

func NewDestroyFuncRef(ref unsafe.Pointer) *DestroyFunc {
	return (*DestroyFunc)(ref)
}

//export destroyFunc6936EE15
func destroyFunc6936EE15(cdata unsafe.Pointer) {
	if destroyFunc6936EE15Func != nil {
		data6936ee15 := (unsafe.Pointer)(unsafe.Pointer(cdata))
		destroyFunc6936EE15Func(data6936ee15)
		return
	}
	panic("callback func has not been set (race?)")
}

var destroyFunc6936EE15Func DestroyFunc

// allocUserDataKeyMemory allocates memory for type C.cairo_user_data_key_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUserDataKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUserDataKeyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUserDataKeyValue = unsafe.Sizeof([1]C.cairo_user_data_key_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UserDataKey) Ref() *C.cairo_user_data_key_t {
	if x == nil {
		return nil
	}
	return x.refb2afcf30
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UserDataKey) Free() {
	if x != nil && x.allocsb2afcf30 != nil {
		x.allocsb2afcf30.(*cgoAllocMap).Free()
		x.refb2afcf30 = nil
	}
}

// NewUserDataKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUserDataKeyRef(ref unsafe.Pointer) *UserDataKey {
	if ref == nil {
		return nil
	}
	obj := new(UserDataKey)
	obj.refb2afcf30 = (*C.cairo_user_data_key_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UserDataKey) PassRef() (*C.cairo_user_data_key_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb2afcf30 != nil {
		return x.refb2afcf30, nil
	}
	memb2afcf30 := allocUserDataKeyMemory(1)
	refb2afcf30 := (*C.cairo_user_data_key_t)(memb2afcf30)
	allocsb2afcf30 := new(cgoAllocMap)
	allocsb2afcf30.Add(memb2afcf30)

	var cunused_allocs *cgoAllocMap
	refb2afcf30.unused, cunused_allocs = (C.int)(x.Unused), cgoAllocsUnknown
	allocsb2afcf30.Borrow(cunused_allocs)

	x.refb2afcf30 = refb2afcf30
	x.allocsb2afcf30 = allocsb2afcf30
	return refb2afcf30, allocsb2afcf30

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UserDataKey) PassValue() (C.cairo_user_data_key_t, *cgoAllocMap) {
	if x.refb2afcf30 != nil {
		return *x.refb2afcf30, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UserDataKey) Deref() {
	if x.refb2afcf30 == nil {
		return
	}
	x.Unused = (int32)(x.refb2afcf30.unused)
}

// packPUcharString creates a Go string backed by *C.uchar and avoids copying.
func packPUcharString(p *C.uchar) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

func (x WriteFunc) PassRef() (ref *C.cairo_write_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if writeFuncF4DFC69Func == nil {
		writeFuncF4DFC69Func = x
	}
	return (*C.cairo_write_func_t)(C.cairo_write_func_t_f4dfc69), nil
}

func (x WriteFunc) PassValue() (ref C.cairo_write_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if writeFuncF4DFC69Func == nil {
		writeFuncF4DFC69Func = x
	}
	return (C.cairo_write_func_t)(C.cairo_write_func_t_f4dfc69), nil
}

func NewWriteFuncRef(ref unsafe.Pointer) *WriteFunc {
	return (*WriteFunc)(ref)
}

//export writeFuncF4DFC69
func writeFuncF4DFC69(cclosure unsafe.Pointer, cdata *C.uchar, clength C.uint) C.cairo_status_t {
	if writeFuncF4DFC69Func != nil {
		closuref4dfc69 := (unsafe.Pointer)(unsafe.Pointer(cclosure))
		dataf4dfc69 := packPUcharString(cdata)
		lengthf4dfc69 := (uint32)(clength)
		retf4dfc69 := writeFuncF4DFC69Func(closuref4dfc69, dataf4dfc69, lengthf4dfc69)
		ret, _ := (C.cairo_status_t)(retf4dfc69), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var writeFuncF4DFC69Func WriteFunc

func (x ReadFunc) PassRef() (ref *C.cairo_read_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if readFunc69800AA2Func == nil {
		readFunc69800AA2Func = x
	}
	return (*C.cairo_read_func_t)(C.cairo_read_func_t_69800aa2), nil
}

func (x ReadFunc) PassValue() (ref C.cairo_read_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if readFunc69800AA2Func == nil {
		readFunc69800AA2Func = x
	}
	return (C.cairo_read_func_t)(C.cairo_read_func_t_69800aa2), nil
}

func NewReadFuncRef(ref unsafe.Pointer) *ReadFunc {
	return (*ReadFunc)(ref)
}

//export readFunc69800AA2
func readFunc69800AA2(cclosure unsafe.Pointer, cdata *C.uchar, clength C.uint) C.cairo_status_t {
	if readFunc69800AA2Func != nil {
		closure69800aa2 := (unsafe.Pointer)(unsafe.Pointer(cclosure))
		data69800aa2 := (*byte)(unsafe.Pointer(cdata))
		length69800aa2 := (uint32)(clength)
		ret69800aa2 := readFunc69800AA2Func(closure69800aa2, data69800aa2, length69800aa2)
		ret, _ := (C.cairo_status_t)(ret69800aa2), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var readFunc69800AA2Func ReadFunc

// allocRectangleIntMemory allocates memory for type C.cairo_rectangle_int_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleIntValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleIntValue = unsafe.Sizeof([1]C.cairo_rectangle_int_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RectangleInt) Ref() *C.cairo_rectangle_int_t {
	if x == nil {
		return nil
	}
	return x.ref182a0d2b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RectangleInt) Free() {
	if x != nil && x.allocs182a0d2b != nil {
		x.allocs182a0d2b.(*cgoAllocMap).Free()
		x.ref182a0d2b = nil
	}
}

// NewRectangleIntRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectangleIntRef(ref unsafe.Pointer) *RectangleInt {
	if ref == nil {
		return nil
	}
	obj := new(RectangleInt)
	obj.ref182a0d2b = (*C.cairo_rectangle_int_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RectangleInt) PassRef() (*C.cairo_rectangle_int_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref182a0d2b != nil {
		return x.ref182a0d2b, nil
	}
	mem182a0d2b := allocRectangleIntMemory(1)
	ref182a0d2b := (*C.cairo_rectangle_int_t)(mem182a0d2b)
	allocs182a0d2b := new(cgoAllocMap)
	allocs182a0d2b.Add(mem182a0d2b)

	var cx_allocs *cgoAllocMap
	ref182a0d2b.x, cx_allocs = (C.int)(x.X), cgoAllocsUnknown
	allocs182a0d2b.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref182a0d2b.y, cy_allocs = (C.int)(x.Y), cgoAllocsUnknown
	allocs182a0d2b.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref182a0d2b.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs182a0d2b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref182a0d2b.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs182a0d2b.Borrow(cheight_allocs)

	x.ref182a0d2b = ref182a0d2b
	x.allocs182a0d2b = allocs182a0d2b
	return ref182a0d2b, allocs182a0d2b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RectangleInt) PassValue() (C.cairo_rectangle_int_t, *cgoAllocMap) {
	if x.ref182a0d2b != nil {
		return *x.ref182a0d2b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RectangleInt) Deref() {
	if x.ref182a0d2b == nil {
		return
	}
	x.X = (int32)(x.ref182a0d2b.x)
	x.Y = (int32)(x.ref182a0d2b.y)
	x.Width = (int32)(x.ref182a0d2b.width)
	x.Height = (int32)(x.ref182a0d2b.height)
}

// allocRectangleMemory allocates memory for type C.cairo_rectangle_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleValue = unsafe.Sizeof([1]C.cairo_rectangle_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rectangle) Ref() *C.cairo_rectangle_t {
	if x == nil {
		return nil
	}
	return x.ref9b663fb6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rectangle) Free() {
	if x != nil && x.allocs9b663fb6 != nil {
		x.allocs9b663fb6.(*cgoAllocMap).Free()
		x.ref9b663fb6 = nil
	}
}

// NewRectangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectangleRef(ref unsafe.Pointer) *Rectangle {
	if ref == nil {
		return nil
	}
	obj := new(Rectangle)
	obj.ref9b663fb6 = (*C.cairo_rectangle_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rectangle) PassRef() (*C.cairo_rectangle_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b663fb6 != nil {
		return x.ref9b663fb6, nil
	}
	mem9b663fb6 := allocRectangleMemory(1)
	ref9b663fb6 := (*C.cairo_rectangle_t)(mem9b663fb6)
	allocs9b663fb6 := new(cgoAllocMap)
	allocs9b663fb6.Add(mem9b663fb6)

	var cx_allocs *cgoAllocMap
	ref9b663fb6.x, cx_allocs = (C.double)(x.X), cgoAllocsUnknown
	allocs9b663fb6.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref9b663fb6.y, cy_allocs = (C.double)(x.Y), cgoAllocsUnknown
	allocs9b663fb6.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref9b663fb6.width, cwidth_allocs = (C.double)(x.Width), cgoAllocsUnknown
	allocs9b663fb6.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref9b663fb6.height, cheight_allocs = (C.double)(x.Height), cgoAllocsUnknown
	allocs9b663fb6.Borrow(cheight_allocs)

	x.ref9b663fb6 = ref9b663fb6
	x.allocs9b663fb6 = allocs9b663fb6
	return ref9b663fb6, allocs9b663fb6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rectangle) PassValue() (C.cairo_rectangle_t, *cgoAllocMap) {
	if x.ref9b663fb6 != nil {
		return *x.ref9b663fb6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Rectangle) Deref() {
	if x.ref9b663fb6 == nil {
		return
	}
	x.X = (float64)(x.ref9b663fb6.x)
	x.Y = (float64)(x.ref9b663fb6.y)
	x.Width = (float64)(x.ref9b663fb6.width)
	x.Height = (float64)(x.ref9b663fb6.height)
}

// allocRectangleListMemory allocates memory for type C.cairo_rectangle_list_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleListValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleListValue = unsafe.Sizeof([1]C.cairo_rectangle_list_t{})

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRectangle transforms a sliced Go data structure into plain C format.
func unpackSRectangle(x []Rectangle) (unpacked *C.cairo_rectangle_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.cairo_rectangle_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cairo_rectangle_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cairo_rectangle_t)(unsafe.Pointer(h.Data))
	return
}

// packSRectangle reads sliced Go data structure out from plain C format.
func packSRectangle(v []Rectangle, ptr0 *C.cairo_rectangle_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRectangleValue]C.cairo_rectangle_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRectangleRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RectangleList) Ref() *C.cairo_rectangle_list_t {
	if x == nil {
		return nil
	}
	return x.ref149ca897
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RectangleList) Free() {
	if x != nil && x.allocs149ca897 != nil {
		x.allocs149ca897.(*cgoAllocMap).Free()
		x.ref149ca897 = nil
	}
}

// NewRectangleListRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectangleListRef(ref unsafe.Pointer) *RectangleList {
	if ref == nil {
		return nil
	}
	obj := new(RectangleList)
	obj.ref149ca897 = (*C.cairo_rectangle_list_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RectangleList) PassRef() (*C.cairo_rectangle_list_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref149ca897 != nil {
		return x.ref149ca897, nil
	}
	mem149ca897 := allocRectangleListMemory(1)
	ref149ca897 := (*C.cairo_rectangle_list_t)(mem149ca897)
	allocs149ca897 := new(cgoAllocMap)
	allocs149ca897.Add(mem149ca897)

	var cstatus_allocs *cgoAllocMap
	ref149ca897.status, cstatus_allocs = (C.cairo_status_t)(x.Status), cgoAllocsUnknown
	allocs149ca897.Borrow(cstatus_allocs)

	var crectangles_allocs *cgoAllocMap
	ref149ca897.rectangles, crectangles_allocs = unpackSRectangle(x.Rectangles)
	allocs149ca897.Borrow(crectangles_allocs)

	var cnum_rectangles_allocs *cgoAllocMap
	ref149ca897.num_rectangles, cnum_rectangles_allocs = (C.int)(x.NumRectangles), cgoAllocsUnknown
	allocs149ca897.Borrow(cnum_rectangles_allocs)

	x.ref149ca897 = ref149ca897
	x.allocs149ca897 = allocs149ca897
	return ref149ca897, allocs149ca897

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RectangleList) PassValue() (C.cairo_rectangle_list_t, *cgoAllocMap) {
	if x.ref149ca897 != nil {
		return *x.ref149ca897, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RectangleList) Deref() {
	if x.ref149ca897 == nil {
		return
	}
	x.Status = (Status)(x.ref149ca897.status)
	packSRectangle(x.Rectangles, x.ref149ca897.rectangles)
	x.NumRectangles = (int32)(x.ref149ca897.num_rectangles)
}

// Ref returns a reference to C object as it is.
func (x *ScaledFont) Ref() *C.cairo_scaled_font_t {
	if x == nil {
		return nil
	}
	return (*C.cairo_scaled_font_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ScaledFont) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewScaledFontRef converts the C object reference into a raw struct reference without wrapping.
func NewScaledFontRef(ref unsafe.Pointer) *ScaledFont {
	return (*ScaledFont)(ref)
}

// NewScaledFont allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewScaledFont() *ScaledFont {
	return (*ScaledFont)(allocScaledFontMemory(1))
}

// allocScaledFontMemory allocates memory for type C.cairo_scaled_font_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocScaledFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfScaledFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfScaledFontValue = unsafe.Sizeof([1]C.cairo_scaled_font_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ScaledFont) PassRef() *C.cairo_scaled_font_t {
	if x == nil {
		x = (*ScaledFont)(allocScaledFontMemory(1))
	}
	return (*C.cairo_scaled_font_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FontFace) Ref() *C.cairo_font_face_t {
	if x == nil {
		return nil
	}
	return (*C.cairo_font_face_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FontFace) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFontFaceRef converts the C object reference into a raw struct reference without wrapping.
func NewFontFaceRef(ref unsafe.Pointer) *FontFace {
	return (*FontFace)(ref)
}

// NewFontFace allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFontFace() *FontFace {
	return (*FontFace)(allocFontFaceMemory(1))
}

// allocFontFaceMemory allocates memory for type C.cairo_font_face_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontFaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontFaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontFaceValue = unsafe.Sizeof([1]C.cairo_font_face_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FontFace) PassRef() *C.cairo_font_face_t {
	if x == nil {
		x = (*FontFace)(allocFontFaceMemory(1))
	}
	return (*C.cairo_font_face_t)(unsafe.Pointer(x))
}

// allocGlyphMemory allocates memory for type C.cairo_glyph_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGlyphMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGlyphValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGlyphValue = unsafe.Sizeof([1]C.cairo_glyph_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Glyph) Ref() *C.cairo_glyph_t {
	if x == nil {
		return nil
	}
	return x.ref5b16733c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Glyph) Free() {
	if x != nil && x.allocs5b16733c != nil {
		x.allocs5b16733c.(*cgoAllocMap).Free()
		x.ref5b16733c = nil
	}
}

// NewGlyphRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGlyphRef(ref unsafe.Pointer) *Glyph {
	if ref == nil {
		return nil
	}
	obj := new(Glyph)
	obj.ref5b16733c = (*C.cairo_glyph_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Glyph) PassRef() (*C.cairo_glyph_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5b16733c != nil {
		return x.ref5b16733c, nil
	}
	mem5b16733c := allocGlyphMemory(1)
	ref5b16733c := (*C.cairo_glyph_t)(mem5b16733c)
	allocs5b16733c := new(cgoAllocMap)
	allocs5b16733c.Add(mem5b16733c)

	var cindex_allocs *cgoAllocMap
	ref5b16733c.index, cindex_allocs = (C.ulong)(x.Index), cgoAllocsUnknown
	allocs5b16733c.Borrow(cindex_allocs)

	var cx_allocs *cgoAllocMap
	ref5b16733c.x, cx_allocs = (C.double)(x.X), cgoAllocsUnknown
	allocs5b16733c.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref5b16733c.y, cy_allocs = (C.double)(x.Y), cgoAllocsUnknown
	allocs5b16733c.Borrow(cy_allocs)

	x.ref5b16733c = ref5b16733c
	x.allocs5b16733c = allocs5b16733c
	return ref5b16733c, allocs5b16733c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Glyph) PassValue() (C.cairo_glyph_t, *cgoAllocMap) {
	if x.ref5b16733c != nil {
		return *x.ref5b16733c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Glyph) Deref() {
	if x.ref5b16733c == nil {
		return
	}
	x.Index = (uint)(x.ref5b16733c.index)
	x.X = (float64)(x.ref5b16733c.x)
	x.Y = (float64)(x.ref5b16733c.y)
}

// allocTextClusterMemory allocates memory for type C.cairo_text_cluster_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextClusterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextClusterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextClusterValue = unsafe.Sizeof([1]C.cairo_text_cluster_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextCluster) Ref() *C.cairo_text_cluster_t {
	if x == nil {
		return nil
	}
	return x.refd989a040
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextCluster) Free() {
	if x != nil && x.allocsd989a040 != nil {
		x.allocsd989a040.(*cgoAllocMap).Free()
		x.refd989a040 = nil
	}
}

// NewTextClusterRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextClusterRef(ref unsafe.Pointer) *TextCluster {
	if ref == nil {
		return nil
	}
	obj := new(TextCluster)
	obj.refd989a040 = (*C.cairo_text_cluster_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextCluster) PassRef() (*C.cairo_text_cluster_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd989a040 != nil {
		return x.refd989a040, nil
	}
	memd989a040 := allocTextClusterMemory(1)
	refd989a040 := (*C.cairo_text_cluster_t)(memd989a040)
	allocsd989a040 := new(cgoAllocMap)
	allocsd989a040.Add(memd989a040)

	var cnum_bytes_allocs *cgoAllocMap
	refd989a040.num_bytes, cnum_bytes_allocs = (C.int)(x.NumBytes), cgoAllocsUnknown
	allocsd989a040.Borrow(cnum_bytes_allocs)

	var cnum_glyphs_allocs *cgoAllocMap
	refd989a040.num_glyphs, cnum_glyphs_allocs = (C.int)(x.NumGlyphs), cgoAllocsUnknown
	allocsd989a040.Borrow(cnum_glyphs_allocs)

	x.refd989a040 = refd989a040
	x.allocsd989a040 = allocsd989a040
	return refd989a040, allocsd989a040

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextCluster) PassValue() (C.cairo_text_cluster_t, *cgoAllocMap) {
	if x.refd989a040 != nil {
		return *x.refd989a040, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextCluster) Deref() {
	if x.refd989a040 == nil {
		return
	}
	x.NumBytes = (int32)(x.refd989a040.num_bytes)
	x.NumGlyphs = (int32)(x.refd989a040.num_glyphs)
}

// allocTextExtentsMemory allocates memory for type C.cairo_text_extents_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextExtentsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextExtentsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextExtentsValue = unsafe.Sizeof([1]C.cairo_text_extents_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextExtents) Ref() *C.cairo_text_extents_t {
	if x == nil {
		return nil
	}
	return x.refe2add9c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextExtents) Free() {
	if x != nil && x.allocse2add9c7 != nil {
		x.allocse2add9c7.(*cgoAllocMap).Free()
		x.refe2add9c7 = nil
	}
}

// NewTextExtentsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextExtentsRef(ref unsafe.Pointer) *TextExtents {
	if ref == nil {
		return nil
	}
	obj := new(TextExtents)
	obj.refe2add9c7 = (*C.cairo_text_extents_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextExtents) PassRef() (*C.cairo_text_extents_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2add9c7 != nil {
		return x.refe2add9c7, nil
	}
	meme2add9c7 := allocTextExtentsMemory(1)
	refe2add9c7 := (*C.cairo_text_extents_t)(meme2add9c7)
	allocse2add9c7 := new(cgoAllocMap)
	allocse2add9c7.Add(meme2add9c7)

	var cx_bearing_allocs *cgoAllocMap
	refe2add9c7.x_bearing, cx_bearing_allocs = (C.double)(x.XBearing), cgoAllocsUnknown
	allocse2add9c7.Borrow(cx_bearing_allocs)

	var cy_bearing_allocs *cgoAllocMap
	refe2add9c7.y_bearing, cy_bearing_allocs = (C.double)(x.YBearing), cgoAllocsUnknown
	allocse2add9c7.Borrow(cy_bearing_allocs)

	var cwidth_allocs *cgoAllocMap
	refe2add9c7.width, cwidth_allocs = (C.double)(x.Width), cgoAllocsUnknown
	allocse2add9c7.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refe2add9c7.height, cheight_allocs = (C.double)(x.Height), cgoAllocsUnknown
	allocse2add9c7.Borrow(cheight_allocs)

	var cx_advance_allocs *cgoAllocMap
	refe2add9c7.x_advance, cx_advance_allocs = (C.double)(x.XAdvance), cgoAllocsUnknown
	allocse2add9c7.Borrow(cx_advance_allocs)

	var cy_advance_allocs *cgoAllocMap
	refe2add9c7.y_advance, cy_advance_allocs = (C.double)(x.YAdvance), cgoAllocsUnknown
	allocse2add9c7.Borrow(cy_advance_allocs)

	x.refe2add9c7 = refe2add9c7
	x.allocse2add9c7 = allocse2add9c7
	return refe2add9c7, allocse2add9c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextExtents) PassValue() (C.cairo_text_extents_t, *cgoAllocMap) {
	if x.refe2add9c7 != nil {
		return *x.refe2add9c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextExtents) Deref() {
	if x.refe2add9c7 == nil {
		return
	}
	x.XBearing = (float64)(x.refe2add9c7.x_bearing)
	x.YBearing = (float64)(x.refe2add9c7.y_bearing)
	x.Width = (float64)(x.refe2add9c7.width)
	x.Height = (float64)(x.refe2add9c7.height)
	x.XAdvance = (float64)(x.refe2add9c7.x_advance)
	x.YAdvance = (float64)(x.refe2add9c7.y_advance)
}

// allocFontExtentsMemory allocates memory for type C.cairo_font_extents_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontExtentsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontExtentsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontExtentsValue = unsafe.Sizeof([1]C.cairo_font_extents_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FontExtents) Ref() *C.cairo_font_extents_t {
	if x == nil {
		return nil
	}
	return x.refbc0b0f3c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FontExtents) Free() {
	if x != nil && x.allocsbc0b0f3c != nil {
		x.allocsbc0b0f3c.(*cgoAllocMap).Free()
		x.refbc0b0f3c = nil
	}
}

// NewFontExtentsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFontExtentsRef(ref unsafe.Pointer) *FontExtents {
	if ref == nil {
		return nil
	}
	obj := new(FontExtents)
	obj.refbc0b0f3c = (*C.cairo_font_extents_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FontExtents) PassRef() (*C.cairo_font_extents_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc0b0f3c != nil {
		return x.refbc0b0f3c, nil
	}
	membc0b0f3c := allocFontExtentsMemory(1)
	refbc0b0f3c := (*C.cairo_font_extents_t)(membc0b0f3c)
	allocsbc0b0f3c := new(cgoAllocMap)
	allocsbc0b0f3c.Add(membc0b0f3c)

	var cascent_allocs *cgoAllocMap
	refbc0b0f3c.ascent, cascent_allocs = (C.double)(x.Ascent), cgoAllocsUnknown
	allocsbc0b0f3c.Borrow(cascent_allocs)

	var cdescent_allocs *cgoAllocMap
	refbc0b0f3c.descent, cdescent_allocs = (C.double)(x.Descent), cgoAllocsUnknown
	allocsbc0b0f3c.Borrow(cdescent_allocs)

	var cheight_allocs *cgoAllocMap
	refbc0b0f3c.height, cheight_allocs = (C.double)(x.Height), cgoAllocsUnknown
	allocsbc0b0f3c.Borrow(cheight_allocs)

	var cmax_x_advance_allocs *cgoAllocMap
	refbc0b0f3c.max_x_advance, cmax_x_advance_allocs = (C.double)(x.MaxXAdvance), cgoAllocsUnknown
	allocsbc0b0f3c.Borrow(cmax_x_advance_allocs)

	var cmax_y_advance_allocs *cgoAllocMap
	refbc0b0f3c.max_y_advance, cmax_y_advance_allocs = (C.double)(x.MaxYAdvance), cgoAllocsUnknown
	allocsbc0b0f3c.Borrow(cmax_y_advance_allocs)

	x.refbc0b0f3c = refbc0b0f3c
	x.allocsbc0b0f3c = allocsbc0b0f3c
	return refbc0b0f3c, allocsbc0b0f3c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FontExtents) PassValue() (C.cairo_font_extents_t, *cgoAllocMap) {
	if x.refbc0b0f3c != nil {
		return *x.refbc0b0f3c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FontExtents) Deref() {
	if x.refbc0b0f3c == nil {
		return
	}
	x.Ascent = (float64)(x.refbc0b0f3c.ascent)
	x.Descent = (float64)(x.refbc0b0f3c.descent)
	x.Height = (float64)(x.refbc0b0f3c.height)
	x.MaxXAdvance = (float64)(x.refbc0b0f3c.max_x_advance)
	x.MaxYAdvance = (float64)(x.refbc0b0f3c.max_y_advance)
}

// Ref returns a reference to C object as it is.
func (x *FontOptions) Ref() *C.cairo_font_options_t {
	if x == nil {
		return nil
	}
	return (*C.cairo_font_options_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FontOptions) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFontOptionsRef converts the C object reference into a raw struct reference without wrapping.
func NewFontOptionsRef(ref unsafe.Pointer) *FontOptions {
	return (*FontOptions)(ref)
}

// NewFontOptions allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFontOptions() *FontOptions {
	return (*FontOptions)(allocFontOptionsMemory(1))
}

// allocFontOptionsMemory allocates memory for type C.cairo_font_options_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontOptionsValue = unsafe.Sizeof([1]C.cairo_font_options_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FontOptions) PassRef() *C.cairo_font_options_t {
	if x == nil {
		x = (*FontOptions)(allocFontOptionsMemory(1))
	}
	return (*C.cairo_font_options_t)(unsafe.Pointer(x))
}

func (x UserScaledFontInitFunc) PassRef() (ref *C.cairo_user_scaled_font_init_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if userScaledFontInitFunc87C5D9CBFunc == nil {
		userScaledFontInitFunc87C5D9CBFunc = x
	}
	return (*C.cairo_user_scaled_font_init_func_t)(C.cairo_user_scaled_font_init_func_t_87c5d9cb), nil
}

func (x UserScaledFontInitFunc) PassValue() (ref C.cairo_user_scaled_font_init_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if userScaledFontInitFunc87C5D9CBFunc == nil {
		userScaledFontInitFunc87C5D9CBFunc = x
	}
	return (C.cairo_user_scaled_font_init_func_t)(C.cairo_user_scaled_font_init_func_t_87c5d9cb), nil
}

func NewUserScaledFontInitFuncRef(ref unsafe.Pointer) *UserScaledFontInitFunc {
	return (*UserScaledFontInitFunc)(ref)
}

//export userScaledFontInitFunc87C5D9CB
func userScaledFontInitFunc87C5D9CB(cscaledFont *C.cairo_scaled_font_t, ccr *C.cairo_t, cextents *C.cairo_font_extents_t) C.cairo_status_t {
	if userScaledFontInitFunc87C5D9CBFunc != nil {
		scaledFont87c5d9cb := (*ScaledFont)(unsafe.Pointer(cscaledFont))
		cr87c5d9cb := (*Cairo)(unsafe.Pointer(ccr))
		extents87c5d9cb := NewFontExtentsRef(unsafe.Pointer(cextents))
		ret87c5d9cb := userScaledFontInitFunc87C5D9CBFunc(scaledFont87c5d9cb, cr87c5d9cb, extents87c5d9cb)
		ret, _ := (C.cairo_status_t)(ret87c5d9cb), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var userScaledFontInitFunc87C5D9CBFunc UserScaledFontInitFunc

func (x UserScaledFontRenderGlyphFunc) PassRef() (ref *C.cairo_user_scaled_font_render_glyph_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if userScaledFontRenderGlyphFunc32C7BE76Func == nil {
		userScaledFontRenderGlyphFunc32C7BE76Func = x
	}
	return (*C.cairo_user_scaled_font_render_glyph_func_t)(C.cairo_user_scaled_font_render_glyph_func_t_32c7be76), nil
}

func (x UserScaledFontRenderGlyphFunc) PassValue() (ref C.cairo_user_scaled_font_render_glyph_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if userScaledFontRenderGlyphFunc32C7BE76Func == nil {
		userScaledFontRenderGlyphFunc32C7BE76Func = x
	}
	return (C.cairo_user_scaled_font_render_glyph_func_t)(C.cairo_user_scaled_font_render_glyph_func_t_32c7be76), nil
}

func NewUserScaledFontRenderGlyphFuncRef(ref unsafe.Pointer) *UserScaledFontRenderGlyphFunc {
	return (*UserScaledFontRenderGlyphFunc)(ref)
}

//export userScaledFontRenderGlyphFunc32C7BE76
func userScaledFontRenderGlyphFunc32C7BE76(cscaledFont *C.cairo_scaled_font_t, cglyph C.ulong, ccr *C.cairo_t, cextents *C.cairo_text_extents_t) C.cairo_status_t {
	if userScaledFontRenderGlyphFunc32C7BE76Func != nil {
		scaledFont32c7be76 := (*ScaledFont)(unsafe.Pointer(cscaledFont))
		glyph32c7be76 := (uint)(cglyph)
		cr32c7be76 := (*Cairo)(unsafe.Pointer(ccr))
		extents32c7be76 := NewTextExtentsRef(unsafe.Pointer(cextents))
		ret32c7be76 := userScaledFontRenderGlyphFunc32C7BE76Func(scaledFont32c7be76, glyph32c7be76, cr32c7be76, extents32c7be76)
		ret, _ := (C.cairo_status_t)(ret32c7be76), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var userScaledFontRenderGlyphFunc32C7BE76Func UserScaledFontRenderGlyphFunc

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// packSPGlyph reads sliced Go data structure out from plain C format.
func packSPGlyph(v []*Glyph, ptr0 **C.cairo_glyph_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.cairo_glyph_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = NewGlyphRef(unsafe.Pointer(ptr1))
	}
}

// packSPTextCluster reads sliced Go data structure out from plain C format.
func packSPTextCluster(v []*TextCluster, ptr0 **C.cairo_text_cluster_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.cairo_text_cluster_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = NewTextClusterRef(unsafe.Pointer(ptr1))
	}
}

func (x UserScaledFontTextToGlyphsFunc) PassRef() (ref *C.cairo_user_scaled_font_text_to_glyphs_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if userScaledFontTextToGlyphsFunc5FC4FFFDFunc == nil {
		userScaledFontTextToGlyphsFunc5FC4FFFDFunc = x
	}
	return (*C.cairo_user_scaled_font_text_to_glyphs_func_t)(C.cairo_user_scaled_font_text_to_glyphs_func_t_5fc4fffd), nil
}

func (x UserScaledFontTextToGlyphsFunc) PassValue() (ref C.cairo_user_scaled_font_text_to_glyphs_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if userScaledFontTextToGlyphsFunc5FC4FFFDFunc == nil {
		userScaledFontTextToGlyphsFunc5FC4FFFDFunc = x
	}
	return (C.cairo_user_scaled_font_text_to_glyphs_func_t)(C.cairo_user_scaled_font_text_to_glyphs_func_t_5fc4fffd), nil
}

func NewUserScaledFontTextToGlyphsFuncRef(ref unsafe.Pointer) *UserScaledFontTextToGlyphsFunc {
	return (*UserScaledFontTextToGlyphsFunc)(ref)
}

//export userScaledFontTextToGlyphsFunc5FC4FFFD
func userScaledFontTextToGlyphsFunc5FC4FFFD(cscaledFont *C.cairo_scaled_font_t, cutf8 *C.char, cutf8Len C.int, cglyphs **C.cairo_glyph_t, cnumGlyphs *C.int, cclusters **C.cairo_text_cluster_t, cnumClusters *C.int, cclusterFlags *C.cairo_text_cluster_flags_t) C.cairo_status_t {
	if userScaledFontTextToGlyphsFunc5FC4FFFDFunc != nil {
		scaledFont5fc4fffd := (*ScaledFont)(unsafe.Pointer(cscaledFont))
		utf85fc4fffd := packPCharString(cutf8)
		utf8Len5fc4fffd := (int32)(cutf8Len)
		var glyphs5fc4fffd []*Glyph
		packSPGlyph(glyphs5fc4fffd, cglyphs)
		numGlyphs5fc4fffd := (*int32)(unsafe.Pointer(cnumGlyphs))
		var clusters5fc4fffd []*TextCluster
		packSPTextCluster(clusters5fc4fffd, cclusters)
		numClusters5fc4fffd := (*int32)(unsafe.Pointer(cnumClusters))
		var clusterFlags5fc4fffd []TextClusterFlags
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&clusterFlags5fc4fffd))
		hxfc4425b.Data = uintptr(unsafe.Pointer(cclusterFlags))
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		ret5fc4fffd := userScaledFontTextToGlyphsFunc5FC4FFFDFunc(scaledFont5fc4fffd, utf85fc4fffd, utf8Len5fc4fffd, glyphs5fc4fffd, numGlyphs5fc4fffd, clusters5fc4fffd, numClusters5fc4fffd, clusterFlags5fc4fffd)
		ret, _ := (C.cairo_status_t)(ret5fc4fffd), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var userScaledFontTextToGlyphsFunc5FC4FFFDFunc UserScaledFontTextToGlyphsFunc

func (x UserScaledFontUnicodeToGlyphFunc) PassRef() (ref *C.cairo_user_scaled_font_unicode_to_glyph_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if userScaledFontUnicodeToGlyphFuncD4A3AAE6Func == nil {
		userScaledFontUnicodeToGlyphFuncD4A3AAE6Func = x
	}
	return (*C.cairo_user_scaled_font_unicode_to_glyph_func_t)(C.cairo_user_scaled_font_unicode_to_glyph_func_t_d4a3aae6), nil
}

func (x UserScaledFontUnicodeToGlyphFunc) PassValue() (ref C.cairo_user_scaled_font_unicode_to_glyph_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if userScaledFontUnicodeToGlyphFuncD4A3AAE6Func == nil {
		userScaledFontUnicodeToGlyphFuncD4A3AAE6Func = x
	}
	return (C.cairo_user_scaled_font_unicode_to_glyph_func_t)(C.cairo_user_scaled_font_unicode_to_glyph_func_t_d4a3aae6), nil
}

func NewUserScaledFontUnicodeToGlyphFuncRef(ref unsafe.Pointer) *UserScaledFontUnicodeToGlyphFunc {
	return (*UserScaledFontUnicodeToGlyphFunc)(ref)
}

//export userScaledFontUnicodeToGlyphFuncD4A3AAE6
func userScaledFontUnicodeToGlyphFuncD4A3AAE6(cscaledFont *C.cairo_scaled_font_t, cunicode C.ulong, cglyphIndex *C.ulong) C.cairo_status_t {
	if userScaledFontUnicodeToGlyphFuncD4A3AAE6Func != nil {
		scaledFontd4a3aae6 := (*ScaledFont)(unsafe.Pointer(cscaledFont))
		unicoded4a3aae6 := (uint)(cunicode)
		glyphIndexd4a3aae6 := (*uint)(unsafe.Pointer(cglyphIndex))
		retd4a3aae6 := userScaledFontUnicodeToGlyphFuncD4A3AAE6Func(scaledFontd4a3aae6, unicoded4a3aae6, glyphIndexd4a3aae6)
		ret, _ := (C.cairo_status_t)(retd4a3aae6), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var userScaledFontUnicodeToGlyphFuncD4A3AAE6Func UserScaledFontUnicodeToGlyphFunc

// allocPathMemory allocates memory for type C.cairo_path_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPathMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPathValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPathValue = unsafe.Sizeof([1]C.cairo_path_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Path) Ref() *C.cairo_path_t {
	if x == nil {
		return nil
	}
	return x.reffd10d41e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Path) Free() {
	if x != nil && x.allocsfd10d41e != nil {
		x.allocsfd10d41e.(*cgoAllocMap).Free()
		x.reffd10d41e = nil
	}
}

// NewPathRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPathRef(ref unsafe.Pointer) *Path {
	if ref == nil {
		return nil
	}
	obj := new(Path)
	obj.reffd10d41e = (*C.cairo_path_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Path) PassRef() (*C.cairo_path_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffd10d41e != nil {
		return x.reffd10d41e, nil
	}
	memfd10d41e := allocPathMemory(1)
	reffd10d41e := (*C.cairo_path_t)(memfd10d41e)
	allocsfd10d41e := new(cgoAllocMap)
	allocsfd10d41e.Add(memfd10d41e)

	var cstatus_allocs *cgoAllocMap
	reffd10d41e.status, cstatus_allocs = (C.cairo_status_t)(x.Status), cgoAllocsUnknown
	allocsfd10d41e.Borrow(cstatus_allocs)

	var cdata_allocs *cgoAllocMap
	reffd10d41e.data, cdata_allocs = (*C.cairo_path_data_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Data)).Data)), cgoAllocsUnknown
	allocsfd10d41e.Borrow(cdata_allocs)

	var cnum_data_allocs *cgoAllocMap
	reffd10d41e.num_data, cnum_data_allocs = (C.int)(x.NumData), cgoAllocsUnknown
	allocsfd10d41e.Borrow(cnum_data_allocs)

	x.reffd10d41e = reffd10d41e
	x.allocsfd10d41e = allocsfd10d41e
	return reffd10d41e, allocsfd10d41e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Path) PassValue() (C.cairo_path_t, *cgoAllocMap) {
	if x.reffd10d41e != nil {
		return *x.reffd10d41e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Path) Deref() {
	if x.reffd10d41e == nil {
		return
	}
	x.Status = (Status)(x.reffd10d41e.status)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Data))
	hxf95e7c8.Data = uintptr(unsafe.Pointer(x.reffd10d41e.data))
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.NumData = (int32)(x.reffd10d41e.num_data)
}

func (x SurfaceObserverCallback) PassRef() (ref *C.cairo_surface_observer_callback_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if surfaceObserverCallback9F372381Func == nil {
		surfaceObserverCallback9F372381Func = x
	}
	return (*C.cairo_surface_observer_callback_t)(C.cairo_surface_observer_callback_t_9f372381), nil
}

func (x SurfaceObserverCallback) PassValue() (ref C.cairo_surface_observer_callback_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if surfaceObserverCallback9F372381Func == nil {
		surfaceObserverCallback9F372381Func = x
	}
	return (C.cairo_surface_observer_callback_t)(C.cairo_surface_observer_callback_t_9f372381), nil
}

func NewSurfaceObserverCallbackRef(ref unsafe.Pointer) *SurfaceObserverCallback {
	return (*SurfaceObserverCallback)(ref)
}

//export surfaceObserverCallback9F372381
func surfaceObserverCallback9F372381(cobserver *C.cairo_surface_t, ctarget *C.cairo_surface_t, cdata unsafe.Pointer) {
	if surfaceObserverCallback9F372381Func != nil {
		observer9f372381 := (*Surface)(unsafe.Pointer(cobserver))
		target9f372381 := (*Surface)(unsafe.Pointer(ctarget))
		data9f372381 := (unsafe.Pointer)(unsafe.Pointer(cdata))
		surfaceObserverCallback9F372381Func(observer9f372381, target9f372381, data9f372381)
		return
	}
	panic("callback func has not been set (race?)")
}

var surfaceObserverCallback9F372381Func SurfaceObserverCallback

func (x RasterSourceAcquireFunc) PassRef() (ref *C.cairo_raster_source_acquire_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rasterSourceAcquireFuncE7404447Func == nil {
		rasterSourceAcquireFuncE7404447Func = x
	}
	return (*C.cairo_raster_source_acquire_func_t)(C.cairo_raster_source_acquire_func_t_e7404447), nil
}

func (x RasterSourceAcquireFunc) PassValue() (ref C.cairo_raster_source_acquire_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rasterSourceAcquireFuncE7404447Func == nil {
		rasterSourceAcquireFuncE7404447Func = x
	}
	return (C.cairo_raster_source_acquire_func_t)(C.cairo_raster_source_acquire_func_t_e7404447), nil
}

func NewRasterSourceAcquireFuncRef(ref unsafe.Pointer) *RasterSourceAcquireFunc {
	return (*RasterSourceAcquireFunc)(ref)
}

//export rasterSourceAcquireFuncE7404447
func rasterSourceAcquireFuncE7404447(cpattern *C.cairo_pattern_t, ccallbackData unsafe.Pointer, ctarget *C.cairo_surface_t, cextents *C.cairo_rectangle_int_t) *C.cairo_surface_t {
	if rasterSourceAcquireFuncE7404447Func != nil {
		patterne7404447 := (*Pattern)(unsafe.Pointer(cpattern))
		callbackDatae7404447 := (unsafe.Pointer)(unsafe.Pointer(ccallbackData))
		targete7404447 := (*Surface)(unsafe.Pointer(ctarget))
		extentse7404447 := NewRectangleIntRef(unsafe.Pointer(cextents))
		rete7404447 := rasterSourceAcquireFuncE7404447Func(patterne7404447, callbackDatae7404447, targete7404447, extentse7404447)
		ret, _ := (*C.cairo_surface_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&rete7404447)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rasterSourceAcquireFuncE7404447Func RasterSourceAcquireFunc

func (x RasterSourceReleaseFunc) PassRef() (ref *C.cairo_raster_source_release_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rasterSourceReleaseFunc659BFE43Func == nil {
		rasterSourceReleaseFunc659BFE43Func = x
	}
	return (*C.cairo_raster_source_release_func_t)(C.cairo_raster_source_release_func_t_659bfe43), nil
}

func (x RasterSourceReleaseFunc) PassValue() (ref C.cairo_raster_source_release_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rasterSourceReleaseFunc659BFE43Func == nil {
		rasterSourceReleaseFunc659BFE43Func = x
	}
	return (C.cairo_raster_source_release_func_t)(C.cairo_raster_source_release_func_t_659bfe43), nil
}

func NewRasterSourceReleaseFuncRef(ref unsafe.Pointer) *RasterSourceReleaseFunc {
	return (*RasterSourceReleaseFunc)(ref)
}

//export rasterSourceReleaseFunc659BFE43
func rasterSourceReleaseFunc659BFE43(cpattern *C.cairo_pattern_t, ccallbackData unsafe.Pointer, csurface *C.cairo_surface_t) {
	if rasterSourceReleaseFunc659BFE43Func != nil {
		pattern659bfe43 := (*Pattern)(unsafe.Pointer(cpattern))
		callbackData659bfe43 := (unsafe.Pointer)(unsafe.Pointer(ccallbackData))
		surface659bfe43 := (*Surface)(unsafe.Pointer(csurface))
		rasterSourceReleaseFunc659BFE43Func(pattern659bfe43, callbackData659bfe43, surface659bfe43)
		return
	}
	panic("callback func has not been set (race?)")
}

var rasterSourceReleaseFunc659BFE43Func RasterSourceReleaseFunc

func (x RasterSourceSnapshotFunc) PassRef() (ref *C.cairo_raster_source_snapshot_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rasterSourceSnapshotFunc518A3707Func == nil {
		rasterSourceSnapshotFunc518A3707Func = x
	}
	return (*C.cairo_raster_source_snapshot_func_t)(C.cairo_raster_source_snapshot_func_t_518a3707), nil
}

func (x RasterSourceSnapshotFunc) PassValue() (ref C.cairo_raster_source_snapshot_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rasterSourceSnapshotFunc518A3707Func == nil {
		rasterSourceSnapshotFunc518A3707Func = x
	}
	return (C.cairo_raster_source_snapshot_func_t)(C.cairo_raster_source_snapshot_func_t_518a3707), nil
}

func NewRasterSourceSnapshotFuncRef(ref unsafe.Pointer) *RasterSourceSnapshotFunc {
	return (*RasterSourceSnapshotFunc)(ref)
}

//export rasterSourceSnapshotFunc518A3707
func rasterSourceSnapshotFunc518A3707(cpattern *C.cairo_pattern_t, ccallbackData unsafe.Pointer) C.cairo_status_t {
	if rasterSourceSnapshotFunc518A3707Func != nil {
		pattern518a3707 := (*Pattern)(unsafe.Pointer(cpattern))
		callbackData518a3707 := (unsafe.Pointer)(unsafe.Pointer(ccallbackData))
		ret518a3707 := rasterSourceSnapshotFunc518A3707Func(pattern518a3707, callbackData518a3707)
		ret, _ := (C.cairo_status_t)(ret518a3707), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rasterSourceSnapshotFunc518A3707Func RasterSourceSnapshotFunc

func (x RasterSourceCopyFunc) PassRef() (ref *C.cairo_raster_source_copy_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rasterSourceCopyFunc84D80D8BFunc == nil {
		rasterSourceCopyFunc84D80D8BFunc = x
	}
	return (*C.cairo_raster_source_copy_func_t)(C.cairo_raster_source_copy_func_t_84d80d8b), nil
}

func (x RasterSourceCopyFunc) PassValue() (ref C.cairo_raster_source_copy_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rasterSourceCopyFunc84D80D8BFunc == nil {
		rasterSourceCopyFunc84D80D8BFunc = x
	}
	return (C.cairo_raster_source_copy_func_t)(C.cairo_raster_source_copy_func_t_84d80d8b), nil
}

func NewRasterSourceCopyFuncRef(ref unsafe.Pointer) *RasterSourceCopyFunc {
	return (*RasterSourceCopyFunc)(ref)
}

//export rasterSourceCopyFunc84D80D8B
func rasterSourceCopyFunc84D80D8B(cpattern *C.cairo_pattern_t, ccallbackData unsafe.Pointer, cother *C.cairo_pattern_t) C.cairo_status_t {
	if rasterSourceCopyFunc84D80D8BFunc != nil {
		pattern84d80d8b := (*Pattern)(unsafe.Pointer(cpattern))
		callbackData84d80d8b := (unsafe.Pointer)(unsafe.Pointer(ccallbackData))
		other84d80d8b := (*Pattern)(unsafe.Pointer(cother))
		ret84d80d8b := rasterSourceCopyFunc84D80D8BFunc(pattern84d80d8b, callbackData84d80d8b, other84d80d8b)
		ret, _ := (C.cairo_status_t)(ret84d80d8b), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rasterSourceCopyFunc84D80D8BFunc RasterSourceCopyFunc

func (x RasterSourceFinishFunc) PassRef() (ref *C.cairo_raster_source_finish_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rasterSourceFinishFuncECE7E85BFunc == nil {
		rasterSourceFinishFuncECE7E85BFunc = x
	}
	return (*C.cairo_raster_source_finish_func_t)(C.cairo_raster_source_finish_func_t_ece7e85b), nil
}

func (x RasterSourceFinishFunc) PassValue() (ref C.cairo_raster_source_finish_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rasterSourceFinishFuncECE7E85BFunc == nil {
		rasterSourceFinishFuncECE7E85BFunc = x
	}
	return (C.cairo_raster_source_finish_func_t)(C.cairo_raster_source_finish_func_t_ece7e85b), nil
}

func NewRasterSourceFinishFuncRef(ref unsafe.Pointer) *RasterSourceFinishFunc {
	return (*RasterSourceFinishFunc)(ref)
}

//export rasterSourceFinishFuncECE7E85B
func rasterSourceFinishFuncECE7E85B(cpattern *C.cairo_pattern_t, ccallbackData unsafe.Pointer) {
	if rasterSourceFinishFuncECE7E85BFunc != nil {
		patternece7e85b := (*Pattern)(unsafe.Pointer(cpattern))
		callbackDataece7e85b := (unsafe.Pointer)(unsafe.Pointer(ccallbackData))
		rasterSourceFinishFuncECE7E85BFunc(patternece7e85b, callbackDataece7e85b)
		return
	}
	panic("callback func has not been set (race?)")
}

var rasterSourceFinishFuncECE7E85BFunc RasterSourceFinishFunc

// Ref returns a reference to C object as it is.
func (x *Region) Ref() *C.cairo_region_t {
	if x == nil {
		return nil
	}
	return (*C.cairo_region_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Region) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRegionRef converts the C object reference into a raw struct reference without wrapping.
func NewRegionRef(ref unsafe.Pointer) *Region {
	return (*Region)(ref)
}

// NewRegion allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRegion() *Region {
	return (*Region)(allocRegionMemory(1))
}

// allocRegionMemory allocates memory for type C.cairo_region_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRegionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRegionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRegionValue = unsafe.Sizeof([1]C.cairo_region_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Region) PassRef() *C.cairo_region_t {
	if x == nil {
		x = (*Region)(allocRegionMemory(1))
	}
	return (*C.cairo_region_t)(unsafe.Pointer(x))
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// allocPGlyphMemory allocates memory for type *C.cairo_glyph_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPGlyphMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPGlyphValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPGlyphValue = unsafe.Sizeof([1]*C.cairo_glyph_t{})

// unpackArgSPGlyph transforms a sliced Go data structure into plain C format.
func unpackArgSPGlyph(x []*Glyph) (unpacked **C.cairo_glyph_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.cairo_glyph_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPGlyphMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.cairo_glyph_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassRef()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.cairo_glyph_t)(unsafe.Pointer(h.Data))
	return
}

// allocPTextClusterMemory allocates memory for type *C.cairo_text_cluster_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTextClusterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTextClusterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPTextClusterValue = unsafe.Sizeof([1]*C.cairo_text_cluster_t{})

// unpackArgSSTextCluster transforms a sliced Go data structure into plain C format.
func unpackArgSSTextCluster(x [][]TextCluster) (unpacked **C.cairo_text_cluster_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.cairo_text_cluster_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPTextClusterMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.cairo_text_cluster_t)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTextClusterMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.cairo_text_cluster_t)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.cairo_text_cluster_t)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.cairo_text_cluster_t)(unsafe.Pointer(h.Data))
	return
}

// packSSTextCluster reads sliced Go data structure out from plain C format.
func packSSTextCluster(v [][]TextCluster, ptr0 **C.cairo_text_cluster_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.cairo_text_cluster_t)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTextClusterValue]C.cairo_text_cluster_t)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTextClusterRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackPUcharString represents the data from Go string as *C.uchar and avoids copying.
func unpackPUcharString(str string) (*C.uchar, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uchar)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}
